>>> FOLDERS >>>
├── navigation
│   ├── __init__.py
│   ├── api_stub.py
│   ├── engine.py
│   ├── logger.py
│   ├── manifest.py
│   └── textual_ui.py
├── dumper.py
├── makedump.json
└── menu-manifest.json
>>> FILES >>>
dumper.py
---
import os
import json
import fnmatch
import sys
import base64
from pathlib import Path

def load_config(config_path=None):
    """Загрузка конфигурации из JSON файла"""
    if config_path is None:
        config_path = "makedump.json"
    
    with open(config_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def should_include(name, include_patterns, exclude_patterns):
    """Проверяет, должен ли быть включен файл/папка по шаблонам"""
    # Проверка исключений
    for exclude in exclude_patterns:
        if fnmatch.fnmatch(name, exclude):
            return False
    
    # Если нет явных включений, включаем всё
    if not include_patterns:
        return True
    
    # Проверка включений
    for include in include_patterns:
        if fnmatch.fnmatch(name, include):
            return True
    
    return False

def get_tree_structure(root_dir, file_include_patterns, file_exclude_patterns, folder_exclude_patterns, prefix=""):
    """Рекурсивно строит древовидную структуру директорий и файлов"""
    result = []
    try:
        items = sorted(os.listdir(root_dir))
    except PermissionError:
        return result
    
    # Фильтруем папки - исключаем только по folder_exclude_patterns
    dirs = [item for item in items 
            if os.path.isdir(os.path.join(root_dir, item)) 
            and should_include(item, ["*"], folder_exclude_patterns)]
    
    # Фильтруем файлы - по file_include_patterns и file_exclude_patterns
    files = [item for item in items 
             if not os.path.isdir(os.path.join(root_dir, item)) 
             and should_include(item, file_include_patterns, file_exclude_patterns)]
    
    # Сортируем: сначала папки, потом файлы
    items = dirs + files
    
    pointers = ["├── "] * (len(items) - 1) + ["└── "]
    
    for pointer, item in zip(pointers, items):
        path = os.path.join(root_dir, item)
        rel_path = os.path.relpath(path, Path(root_dir).parent)
        
        result.append(f"{prefix}{pointer}{item}")
        
        if os.path.isdir(path):
            extension = "│   " if pointer == "├── " else "    "
            result.extend(get_tree_structure(
                path, 
                file_include_patterns, 
                file_exclude_patterns, 
                folder_exclude_patterns, 
                prefix + extension
            ))
    
    return result

def dump_folders(config, output_file):
    """Дамп структуры папок"""
    print(">>> FOLDERS >>>", file=output_file)
    
    for source in config['folders']['sources']:
        root = source['root']
        if root == ".":
            root = os.getcwd()
        
        # Для папок: включаем ВСЕ папки (кроме исключенных), но фильтруем файлы по шаблонам
        file_include = source.get('include', [])
        file_exclude = source.get('exclude', [])
        folder_exclude = source.get('exclude', [])  # Для папок используем только exclude
        
        output_template = config['folders']['output']
        
        # Если шаблон содержит древовидную структуру
        if "├──" in output_template or "└──" in output_template:
            tree_lines = get_tree_structure(root, file_include, file_exclude, folder_exclude)
            for line in tree_lines:
                print(line, file=output_file)
        else:
            # Обычный вывод плоского списка
            for dirpath, dirnames, filenames in os.walk(root):
                # Фильтруем папки
                dirnames[:] = [d for d in dirnames if should_include(d, ["*"], folder_exclude)]
                
                for dirname in dirnames:
                    full_path = os.path.join(dirpath, dirname)
                    rel_path = os.path.relpath(full_path, root)
                    
                    output_line = output_template
                    if "@.name" in output_line:
                        output_line = output_line.replace('@.name', dirname)
                    if "@.path" in output_line:
                        output_line = output_line.replace('@.path', rel_path)
                    print(output_line, file=output_file)

def dump_files(config, output_file):
    """Дамп содержимого файлов"""
    print(">>> FILES >>>", file=output_file)
    
    for source in config['files']['sources']:
        root = source['root']
        if root == ".":
            root = os.getcwd()
        
        include = source['include']
        exclude = source['exclude']
        
        for dirpath, dirnames, filenames in os.walk(root):
            for filename in filenames:
                if should_include(filename, include, exclude):
                    file_path = os.path.join(dirpath, filename)
                    rel_path = os.path.relpath(file_path, root)
                    
                    try:
                        # Пробуем прочитать как текстовый файл
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                    except UnicodeDecodeError:
                        # Если не текстовый, читаем как бинарный и кодируем в base64
                        with open(file_path, 'rb') as f:
                            content = base64.b64encode(f.read()).decode('ascii')
                    
                    output = config['files']['output']
                    output = output.replace('@.name', rel_path)
                    output = output.replace('@.data', content)
                    print(output, file=output_file)

def main():
    """Основная функция"""
    # Парсинг аргументов
    config_path = None
    output_path = "output.txt"
    
    for arg in sys.argv[1:]:
        if arg.endswith('.json'):
            config_path = arg
        else:
            output_path = arg
    
    config = load_config(config_path)
    
    # Создание директории для выходного файла если нужно
    os.makedirs(os.path.dirname(output_path) if os.path.dirname(output_path) else '.', exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as output_file:
        dump_folders(config, output_file)
        dump_files(config, output_file)
    
    print(f"Дамп успешно создан: {output_path}")

if __name__ == "__main__":
    main()
makedump.json
---
{
  "folders": {
    "sources": [
      {
        "root": ".",
        "include": ["*.py", "*.json"],
        "exclude": [".git", ".py*", "__py*"]
      }
    ],
    "output": "├── @.path"
  },
  "files": {
    "sources": [
      {
        "root": ".",
        "include": ["*.py","*.json"],
        "exclude": []
      }
    ],
    "output": "@.name\n---\n@.data"
  }
}
menu-manifest.json
---
{
  "defaults": {
    "back_button_label": "< Назад",
    "chat_mode": {
      "finish_commands": ["/finish", "/start"],
      "finish_button_label": "Закончить разговор"
    },
    "pagination": {
      "page_size": 8,
      "prev_label": "<<",
      "next_label": ">>"
    }
  },
  "screens": {
    "main": {
      "title": "Вы находитесь в главном меню",
      "type": "static",
      "buttons": [
        { "label": "Мои треки", "target": "tracks" },
        { "label": "Поставить отметки", "target": "quick_grade" },
        { "label": "Ближайшие встречи", "target": "meetings" },
        { "label": "Разговорный режим", "target": "chat_mode" },
        { "label": "Мои предпочтения...", "target": "prefs" },
        { "label": "Помощь от ИИ", "target": "ai_help" },
        { "label": "Тест: Алфавит", "target": "alphabet" }
      ]
    },
    "tracks": {
      "title": "Ваши курсы (треки)",
      "type": "dynamic",
      "data_source": {
        "url": "/api/teacher/tracks",
        "method": "GET"
      },
      "button_template": {
        "label_field": "name",
        "target_screen": "track_detail",
        "context_fields": {
          "track_id": "id",
          "track_name": "name"
        }
      },
      "back_path": "main"
    },
    "track_detail": {
      "title": "Трек: {{track_name}}",
      "type": "static",
      "buttons": [
        { "label": "Настройка", "target": "track_settings" },
        { "label": "Студенты", "target": "track_students" }
      ],
      "back_path": "tracks"
    },
    "track_settings": {
      "title": "Настройки трека «{{track_name}}»",
      "type": "static",
      "buttons": [
        { "label": "Изменить название", "action": "edit_name" },
        { "label": "Изменить даты", "target": "track_dates" }
      ],
      "back_path": "track_detail"
    },
    "track_dates": {
      "title": "Даты проведения",
      "type": "static",
      "buttons": [
        { "label": "События", "target": "track_events" }
      ],
      "back_path": "track_settings"
    },
    "track_events": {
      "title": "События в треке",
      "type": "static",
      "buttons": [
        { "label": "Добавить по расписанию", "action": "add_recurring_event" },
        { "label": "Добавить событие", "action": "add_one_time_event" }
      ],
      "back_path": "track_dates"
    },
    "track_students": {
      "title": "Студенты в треке «{{track_name}}»",
      "type": "dynamic",
      "data_source": {
        "url": "/api/tracks/{{track_id}}/students",
        "method": "GET"
      },
      "button_template": {
        "label_field": "full_name",
        "target_screen": "student_profile",
        "context_fields": {
          "student_id": "id",
          "student_name": "full_name"
        }
      },
      "back_path": "track_detail"
    },
    "student_profile": {
      "title": "Студент: {{student_name}}",
      "type": "static",
      "buttons": [
        { "label": "Открыть профиль", "action": "open_full_profile" },
        { "label": "Поставить отметку", "target": "select_metric" }
      ],
      "back_path": "track_students"
    },
    "select_metric": {
      "title": "Выберите метрику для {{student_name}}",
      "type": "dynamic",
      "layout": "grid",
      "columns": 3,
      "supports_multi_select": false,
      "data_source": {
        "url": "/api/metrics",
        "method": "GET"
      },
      "button_template": {
        "label_field": "name",
        "target_screen": "confirm_mark",
        "context_fields": {
          "metric_id": "id",
          "metric_name": "name"
        }
      },
      "back_path": "CONTEXTUAL"
    },
    "confirm_mark": {
      "title": "Подтвердите: отметить {{student_name}} по метрике «{{metric_name}}»?",
      "type": "static",
      "buttons": [
        { "label": "Да", "action": "submit_mark", "payload": "true" },
        { "label": "Нет", "target": "select_metric" }
      ],
      "back_path": "select_metric"
    },
    "alphabet": {
      "title": "Выберите букву фамилии студента",
      "type": "static",
      "paginated": true,
      "supports_multi_select": false,
      "items": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
      "back_path": "main"
    },
    "chat_mode": {
      "title": "Вы вошли в разговорный режим. Задайте вопрос или опишите ситуацию.",
      "type": "chat_input",
      "back_path": "main",
      "ai_api": {
        "url": "/api/ai/teacher-assist",
        "method": "POST",
        "body_template": {
          "user_id": "{{user_id}}",
          "context": "{{chat_history}}",
          "query": "{{user_message}}"
        }
      }
    },
    "ai_help": {
      "title": "Опишите, в чём вам нужна помощь (например: «Как мотивировать отстающего?»)",
      "type": "chat_input",
      "back_path": "main",
      "ai_api": {
        "url": "/api/ai/help",
        "method": "POST",
        "body_template": {
          "user_role": "teacher",
          "request": "{{user_message}}"
        }
      }
    },
    "quick_grade": {
      "title": "Быстрый выбор: для кого ставим отметку?",
      "type": "dynamic",
      "data_source": {
        "url": "/api/teacher/recent_students",
        "method": "GET"
      },
      "button_template": {
        "label_field": "full_name",
        "target_screen": "select_metric",
        "context_fields": {
          "student_id": "id",
          "student_name": "full_name"
        }
      },
      "back_path": "main"
    }
  }
}
navigation\api_stub.py
---
# navigation/api_stub.py
from typing import Any, Dict, List
import json

class APISimulator:
    """
    Умная заглушка для внешних API.
    Легко расширить: просто добавь ключ в MOCK_DATA.
    В продакшене — замени на requests/aiohttp.
    """
    MOCK_DATA = {
        "/api/teacher/tracks": [
            {"id": "game-design", "name": "Геймдизайн"},
            {"id": "architecture", "name": "Архитектура"},
        ],
        "/api/metrics": [
            {"id": "creative", "name": "Креативность"},
            {"id": "result", "name": "Результат"},
            {"id": "teamwork", "name": "Работа в команде"},
            {"id": "initiative", "name": "Инициативность"},
            {"id": "discipline", "name": "Дисциплина"},
            {"id": "communication", "name": "Коммуникация"},
            {"id": "problem_solving", "name": "Решение проблем"},
            {"id": "leadership", "name": "Лидерство"},
            {"id": "adaptability", "name": "Адаптивность"},
            {"id": "accuracy", "name": "Точность"},
            {"id": "persistence", "name": "Настойчивость"},
            {"id": "ethics", "name": "Этичность"},
        ],
        "/api/tracks/game-design/students": [
            {"id": "ivanov", "full_name": "Иванов Иван"},
            {"id": "petrov", "full_name": "Петров Пётр"},
        ],
        "/api/tracks/architecture/students": [
            {"id": "sidorov", "full_name": "Сидоров Сидор"},
        ],
        "/api/teacher/recent_students": [
            {"id": "ivanov", "full_name": "Иванов Иван"},
            {"id": "sidorov", "full_name": "Сидоров Сидор"},
        ]
    }

    def call(self, url: str, method: str = "GET", **kwargs) -> List[Dict[str, Any]]:
        """
        Имитирует API-вызов.
        :param url: путь (может содержать шаблоны, например /api/tracks/{{track_id}}/students)
        :param method: HTTP-метод (игнорируется в заглушке)
        :return: список объектов
        """
        # 🔥 ОПАСНОЕ МЕСТО: если URL не найден — упадём!
        # В продакшене: оберни в try/except и верни пустой список или ошибку
        if url in self.MOCK_DATA:
            return self.MOCK_DATA[url]
        
        # Попытка найти "по шаблону" (упрощённо)
        # Например: /api/tracks/game-design/students → ищем по базовому пути
        for key in self.MOCK_DATA:
            if key.startswith("/api/tracks/") and key.endswith("/students"):
                if url.startswith("/api/tracks/") and url.endswith("/students"):
                    return self.MOCK_DATA[key]  # возвращаем первый подходящий

        # Если ничего не найдено — логгируем и возвращаем пустой список
        return []
navigation\engine.py
---
import copy
import time
from typing import Any, Dict, List, Optional, Union
from .logger import NavigationLogger
from .api_stub import APISimulator
from .manifest import ManifestLoader

class NavigationEngine:
    def __init__(
        self,
        manifest_path: str = "menu-manifest.json",
        logger: Optional[NavigationLogger] = None,
        api_client: Optional[Any] = None
    ):
        self.manifest = ManifestLoader(manifest_path)
        self.logger = logger or NavigationLogger()
        self.api_client = api_client or APISimulator()
        self._user_states: Dict[str, Dict[str, Any]] = {}

    def init_user(self, user_id: str):
        self._user_states[user_id] = {
            "current_screen": "main",
            "context": {"user_id": user_id},
            "return_stack": [],
            "pagination": {},
            "selections": [] # <-- Новое поле для истории выборов
        }
        self.logger.log_view_rendered(user_id, "main", "Инициализация")

    def get_user_state(self, user_id: str) -> Dict[str, Any]:
        if user_id not in self._user_states:
            self.init_user(user_id)
        return self._user_states[user_id]

    def get_current_view(self, user_id: str) -> Dict[str, Any]:
        state = self.get_user_state(user_id)
        screen_id = state["current_screen"]
        screen_def = self.manifest.screens.get(screen_id)

        if not screen_def:
            self.logger.log_error(f"Экран не найден: {screen_id}")
            return {
                "text": "Ошибка: экран не найден",
                "actions": [{"id": "back", "label": "< Назад", "type": "back"}],
                "screen_type": "error"
            }

        title = self._render_template(screen_def["title"], state["context"])

        # Обработка чата: возвращаем специальный тип
        if screen_def["type"] == "chat_input":
            # Возвращаем текст и тип, но без кнопок
            # GUI должен отобразить Input и обработать команды
            self.logger.log_view_rendered(user_id, screen_id, title)
            return {"text": title, "actions": [], "screen_type": "chat_input"}

        if screen_def["type"] == "dynamic":
            actions = self._build_dynamic_actions(user_id, screen_def, state["context"])
        elif screen_def.get("paginated"):
            actions = self._build_paginated_actions(user_id, screen_def, state["context"])
        else:
            actions = self._build_static_actions(screen_def)

        back_path = screen_def.get("back_path")
        if back_path:
            back_label = screen_def.get("back_label", self.manifest.defaults["back_button_label"])
            actions.append({"id": "back", "label": back_label, "type": "back"})

        self.logger.log_view_rendered(user_id, screen_id, title)
        # Добавляем информацию о layout, если есть
        view_data = {"text": title, "actions": actions, "screen_type": screen_def["type"]}
        if screen_def.get("layout") == "grid":
            view_data["layout"] = "grid"
            view_data["columns"] = screen_def.get("columns", 1)
        return view_data

    def _render_template(self, template: str, context: Dict[str, Any]) -> str:
        result = template
        for key, value in context.items():
            result = result.replace(f"{{{{{key}}}}}", str(value))
        return result

    def _record_selection(self, user_id: str, screen_id: str, selected_item: Dict[str, Any]):
        """
        Записывает выбор пользователя.
        Если экран не поддерживает мультивыбор, удаляет предыдущие выборы на этом экране.
        """
        state = self.get_user_state(user_id)
        screen_def = self.manifest.screens.get(screen_id)
        supports_multi = screen_def.get("supports_multi_select", False)

        if not supports_multi:
            # Удаляем все предыдущие выборы на этом экране
            state["selections"] = [sel for sel in state["selections"] if sel.get("screen_id") != screen_id]

        # Добавляем новый выбор
        # Используем time.time() для timestamp
        state["selections"].append({
            "screen_id": screen_id,
            "selected_item": selected_item,
            "timestamp": time.time()
        })

    def _build_static_actions(self, screen_def: Dict[str, Any]) -> List[Dict[str, Any]]:
        actions = []
        for i, btn in enumerate(screen_def["buttons"]):
            action_dict = {
                "id": f"static_{i}",
                "label": btn["label"],
            }
            # Проверяем, есть ли 'target' — если есть, то это навигация
            if "target" in btn:
                action_dict["type"] = "navigate"
                action_dict["target"] = btn["target"]
            # Если 'target' нет, но есть 'action' — это действие
            elif "action" in btn:
                action_dict["type"] = "action"
                action_dict["action"] = btn["action"]
            # Если нет ни 'target', ни 'action', ставим 'unknown' и логируем
            else:
                action_dict["type"] = "unknown"
                self.logger.log_error(f"Кнопка не имеет ни 'target', ни 'action': {btn}")

            # Добавляем payload, если он есть
            if "payload" in btn:
                action_dict["payload"] = btn["payload"]

            actions.append(action_dict)
        return actions

    def _build_dynamic_actions(self, user_id: str, screen_def: Dict[str, Any], context: Dict[str, Any]) -> List[Dict[str, Any]]:
        url = self._render_template(screen_def["data_source"]["url"], context)
        self.logger.log_api_call(url, screen_def["data_source"]["method"])
        items = self.api_client.call(url, screen_def["data_source"]["method"])
        actions = []
        template = screen_def["button_template"]
        for i, item in enumerate(items):
            next_context = {}
            for ctx_key, item_key in template.get("context_fields", {}).items():
                next_context[ctx_key] = item.get(item_key, "")
            actions.append({
                "id": f"dynamic_{i}",
                "label": item.get(template["label_field"], f"Item {i}"),
                "type": "navigate",
                "target": template["target_screen"],
                "context": next_context
            })
        return actions

    def _build_paginated_actions(self, user_id: str, screen_def: Dict[str, Any], context: Dict[str, Any]) -> List[Dict[str, Any]]:
        items = screen_def["items"]
        page_size = self.manifest.defaults["pagination"]["page_size"]
        pagination_state = self._user_states[user_id]["pagination"]
        screen_id_key = screen_def.get("id", "unknown")
        current_page = pagination_state.get(screen_id_key, 0)
        start = current_page * page_size
        end = start + page_size
        page_items = items[start:end]
        actions = []
        for i, item in enumerate(page_items):
            actions.append({
                "id": f"paginated_{start + i}",
                "label": str(item),
                "type": "navigate",
                "target": screen_def.get("target", "item_selected"),
                "payload": str(item)
            })

        if end < len(items):
            actions.append({
                "id": "next_page",
                "label": self.manifest.defaults["pagination"]["next_label"],
                "type": "paginate",
                "direction": "next",
                "screen_id": screen_id_key
            })
        if current_page > 0:
            actions.append({
                "id": "prev_page",
                "label": self.manifest.defaults["pagination"]["prev_label"],
                "type": "paginate",
                "direction": "prev",
                "screen_id": screen_id_key
            })
        return actions

    def handle_action(self, user_id: str, action_data: Dict[str, Any]) -> Union[Dict[str, Any], None]: # <-- Вот тут-то и была беда!
        state = self.get_user_state(user_id)
        action_type = action_data["type"]
        self.logger.log_user_action(user_id, "unknown", action_data["label"])
        if action_type == "back":
            self._handle_back(user_id, state)
        elif action_type == "navigate":
            self._handle_navigate(user_id, state, action_data)
            # Записываем выбор при навигации
            # Предполагаем, что navigate - это выбор, если есть target
            if "target" in action_data:
                self._record_selection(user_id, state["current_screen"], {"type": "navigate", "target": action_data["target"]})
        elif action_type == "paginate":
            self._handle_paginate(user_id, state, action_data)
        elif action_type == "action":
            # Обработка действий, например submit_mark
            if "action" in action_data: # <-- Исправила и тут action_data
                if action_data["action"] == "submit_mark":
                    self._submit_mark(user_id, state, action_data) # Логика возврата внутри
                    # Записываем выбор действия
                    self._record_selection(user_id, state["current_screen"], {"type": "action", "action": action_data["action"]})
                else:
                    self.logger.log_error(f"Неизвестное действие: {action_data['action']}")
            else:
                self.logger.log_error(f"Действие не имеет ключа 'action': {action_data}")
        else:
            self.logger.log_error(f"Неизвестный тип действия: {action_type}")

    def _handle_back(self, user_id: str, state: Dict[str, Any]):
        current_screen = state["current_screen"]
        screen_def = self.manifest.screens.get(current_screen)
        if not screen_def:
            state["current_screen"] = "main"
            return
        back_path = screen_def.get("back_path")
        if back_path == "CONTEXTUAL":
            if state["return_stack"]:
                state["current_screen"] = state["return_stack"].pop()
            else:
                state["current_screen"] = "main"
        elif back_path:
            state["current_screen"] = back_path
        else:
            state["current_screen"] = "main"

    def _handle_navigate(self, user_id: str, state: Dict[str, Any], action_data: Dict[str, Any]): # <-- Исправила и тут action_data
        target_screen = action_data["target"]
        if target_screen not in self.manifest.screens:
            self.logger.log_error(f"Целевой экран не найден: {target_screen}")
            return
        next_screen_def = self.manifest.screens.get(target_screen, {})
        if next_screen_def.get("back_path") == "CONTEXTUAL":
            state["return_stack"].append(state["current_screen"])
        state["current_screen"] = target_screen
        if "context" in action_data: # <-- Исправила и тут action_data
            state["context"].update(action_data["context"])

    def _handle_paginate(self, user_id: str, state: Dict[str, Any], action_data: Dict[str, Any]): # <-- Исправила и тут action_data
        screen_id = action_data["screen_id"]
        direction = action_data["direction"]
        pagination_state = state["pagination"]
        current_page = pagination_state.get(screen_id, 0)
        new_page = current_page + (1 if direction == "next" else -1)
        pagination_state[screen_id] = max(0, new_page)

    def _submit_mark(self, user_id: str, state: Dict[str, Any], action_data: Dict[str, Any]): # <-- Исправила и тут action_data
        # Логгируем API вызов
        self.logger.log_api_call("/api/marks", "POST")
        # Сохраняем важные данные контекста (например, student_id, student_name)
        # которые должны остаться при возврате к select_metric
        saved_context = {key: value for key, value in state["context"].items() if key in ["student_id", "student_name"]}
        # Устанавливаем экран на 'select_metric' (указан в back_path для confirm_mark)
        screen_def = self.manifest.screens.get(state["current_screen"]) # Текущий экран - confirm_mark
        back_path = screen_def.get("back_path") if screen_def else "main"
        if back_path == "select_metric": # Явно проверяем, куда возвращаться
            state["current_screen"] = "select_metric"
            # Восстанавливаем контекст студента
            state["context"].update(saved_context)
            # Очищаем return_stack, так как возврат не по нему
            state["return_stack"] = []
        else:
            # Если back_path не select_metric, возвращаемся по стеку или на main
            if state["return_stack"]:
                state["current_screen"] = state["return_stack"].pop()
            else:
                state["current_screen"] = "main"

    def handle_user_input(self, user_id: str, text: str):
        state = self.get_user_state(user_id)
        screen_id = state["current_screen"]
        screen_def = self.manifest.screens.get(screen_id)

        # Проверяем, находится ли пользователь в чат-режиме
        if screen_def and screen_def.get("type") == "chat_input":
            self.logger.log_user_action(user_id, "user_input", f"«{text}»")
            # Проверяем команды finish
            finish_commands = self.manifest.defaults["chat_mode"]["finish_commands"]
            if text.strip() in finish_commands:
                # Возвращаемся на back_path
                back_path = screen_def.get("back_path", "main")
                state["current_screen"] = back_path
                # Очищаем контекст чата, если есть
                # (например, если хранится история, её можно сбросить)
                # state["context"].pop("chat_history", None)
                return # Выход из обработки, обновление UI произойдёт в вызывающем коде

            # Имитация вызова AI
            # В реальности тут будет вызов API
            ai_response = f"Имитация ответа AI на: {text}"
            # В реальности, результат AI мог бы быть добавлен в контекст или отдельное поле
            # для отображения в GUI.
            # Например: state["context"]["last_ai_response"] = ai_response
            # Или, в GUI, это будет отображено как сообщение от бота.
            # Мы просто логгируем имитацию.
            self.logger.log_api_call("/api/ai/teacher-assist", "POST")
            self.logger.logger.info(f"USER[{user_id}] AI_RESPONSE: {ai_response}")

        else:
            # Если не в чат-режиме, можно игнорировать или логировать
            self.logger.log_user_action(user_id, "user_input_ignored", f"«{text}» - not in chat mode")

navigation\logger.py
---
import logging
from typing import Optional

class NavigationLogger:
    def __init__(self, name: str = "NavigationEngine", level: int = logging.INFO, log_file: str = "navigation.log"):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        if not self.logger.handlers:
            formatter = logging.Formatter(
                "[%(asctime)s] %(name)s :: %(levelname)s :: %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S"
            )
            # Только файл — без консоли
            file_handler = logging.FileHandler(log_file, encoding="utf-8")
            file_handler.setFormatter(formatter)
            self.logger.addHandler(file_handler)

    def log_view_rendered(self, user_id: str, screen_id: str, text: str):
        self.logger.info(f"USER[{user_id}] VIEW[{screen_id}]: {text[:60]}...")

    def log_user_action(self, user_id: str, action_id: str, label: str):
        self.logger.info(f"USER[{user_id}] ACTION: '{label}' (id={action_id})")

    def log_api_call(self, url: str, method: str):
        self.logger.debug(f"API CALL: {method} {url}")

    def log_error(self, message: str):
        self.logger.error(message)
navigation\manifest.py
---
import json
from typing import Dict, Any

class ManifestLoader:
    def __init__(self, manifest_path: str = "menu-manifest.json"):
        self.manifest_path = manifest_path
        self.data = self._load()

    def _load(self) -> Dict[str, Any]:
        try:
            with open(self.manifest_path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            raise FileNotFoundError(f"Манифест не найден: {self.manifest_path}")
        except json.JSONDecodeError as e:
            raise ValueError(f"Невалидный JSON: {e}")
        if "screens" not in data:
            raise ValueError("Манифест должен содержать 'screens'")
        if "defaults" not in data:
            data["defaults"] = {}
        return data

    @property
    def screens(self) -> Dict[str, Any]:
        return self.data["screens"]

    @property
    def defaults(self) -> Dict[str, Any]:
        return self.data["defaults"]
navigation\textual_ui.py
---
from textual.app import App, ComposeResult
from textual.widgets import Static, Button, Footer
from textual.containers import Vertical
from .engine import NavigationEngine

class NavigationTextualApp(App):
    CSS = """
    Vertical {
        align: center middle;
    }
    #title {
        text-align: center;
        margin: 2 0;
        color: $accent;
        text-style: bold;
    }
    Button {
        width: 40;
        margin: 1 0;
    }
    """

    def __init__(self):
        super().__init__()
        self.engine = NavigationEngine()
        self.user_id = "test-user"
        self.engine.init_user(self.user_id)

    def compose(self) -> ComposeResult:
        yield Static("", id="title")
        yield Vertical(id="buttons")
        yield Footer()

    def update_ui(self):
        view = self.engine.get_current_view(self.user_id)
        self.query_one("#title", Static).update(view["text"])
        buttons_container = self.query_one("#buttons", Vertical)
        buttons_container.remove_children()
        self._buttons = []
        for action in view["actions"]:
            # НЕТ id — Textual сам управляет уникальностью
            btn = Button(action["label"])
            btn.action_data = action
            buttons_container.mount(btn)
            self._buttons.append(btn)
        if self._buttons:
            self.set_focus(self._buttons[0])

    def on_mount(self):
        self.update_ui()

    def on_button_pressed(self, event: Button.Pressed):
        action_data = event.button.action_data
        # ✅ Передаём только user_id и action_data
        self.engine.handle_action(self.user_id, action_data)
        self.update_ui()

if __name__ == "__main__":
    NavigationTextualApp().run()
navigation\__init__.py
---

